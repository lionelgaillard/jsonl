#!/usr/bin/env node
(() => {
  var __defineProperty = Object.defineProperty;
  var __hasOwnProperty = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => {
    return __defineProperty(target, "__esModule", {value: true});
  };
  var __exportStar = (target, module) => {
    __markAsModule(target);
    if (typeof module === "object" || typeof module === "function") {
      for (let key in module)
        if (!__hasOwnProperty.call(target, key) && key !== "default")
          __defineProperty(target, key, {get: () => module[key], enumerable: true});
    }
    return target;
  };
  var __toModule = (module) => {
    if (module && module.__esModule)
      return module;
    return __exportStar(__defineProperty({}, "default", {value: module, enumerable: true}), module);
  };

  // src/cli.ts
  const commander = __toModule(require("commander"));
  const fs_extra6 = __toModule(require("fs-extra"));
  const path4 = __toModule(require("path"));

  // src/files.ts
  const fs_extra = __toModule(require("fs-extra"));
  const glob = __toModule(require("glob"));
  function resolvePattern(pattern) {
    return new Promise((resolve, reject) => glob.default(pattern, (error, matches) => error ? reject(error) : resolve(matches)));
  }
  async function loadFile(path5) {
    return {
      path: path5,
      content: await fs_extra.readFile(path5, "utf8")
    };
  }
  async function loadFiles(pattern) {
    const paths = await resolvePattern(pattern);
    return Promise.all(paths.map((path5) => loadFile(path5)));
  }

  // src/keys.ts
  function serializeKeys(keys4) {
    return keys4.join("\n") + "\n";
  }
  function deserializeKeys(content) {
    return content.split("\n").map((k) => k.trim()).filter(Boolean);
  }

  // src/stream.ts
  async function read(stream7) {
    const chunks = [];
    for await (const chunk of stream7) {
      chunks.push(chunk);
    }
    return Buffer.concat(chunks).toString("utf8");
  }
  function write(stream7, data) {
    return new Promise((resolve) => stream7.write(data, "utf8", () => resolve()));
  }

  // src/translations.ts
  const fs_extra2 = __toModule(require("fs-extra"));
  const path = __toModule(require("path"));

  // src/objects.ts
  function getKeys(data, prefix = "") {
    return Object.keys(data).reduce((keys4, key) => {
      if (!data[key] || typeof data[key] === "string") {
        keys4.push(prefix + key);
      } else {
        keys4 = [...keys4, ...getKeys(data[key], prefix + key + ".")];
      }
      return keys4;
    }, []);
  }

  // src/translations.ts
  class TranslationFile {
    constructor(path5, data) {
      this.path = path5;
      this.data = data;
      this._keys = null;
    }
    get locale() {
      return getLocale(this.path);
    }
    get keys() {
      if (this._keys === null) {
        this._keys = getTranslationKeys(this.data);
      }
      return this._keys;
    }
    get(key) {
      return getTranslationValue(this.data, key);
    }
    add(key, value) {
      if (this._keys) {
        this._keys.push(key);
      }
      return addTranslationKey(this.data, key, value);
    }
    delete(key) {
      if (this._keys) {
        this._keys = this._keys.filter((k) => k !== key);
      }
      return deleteTranslationKey(this.data, key);
    }
    save() {
      return saveTranslation(this);
    }
  }
  class ComparedTranslationFile extends TranslationFile {
    constructor() {
      super(...arguments);
      this.additions = [];
      this.substractions = [];
    }
  }
  async function saveTranslation(file) {
    await fs_extra2.writeJson(file.path, sortTranslation(file.data), {spaces: 2});
  }
  async function saveTranslations(files3) {
    await Promise.all(files3.map((t) => saveTranslation(t)));
  }
  async function loadTranslation(path5) {
    const data = await fs_extra2.readJson(path5);
    return new TranslationFile(path5, data);
  }
  async function loadTranslations(pattern) {
    const paths = await resolvePattern(pattern);
    return Promise.all(paths.map((path5) => loadTranslation(path5)));
  }
  function serializeComparedTranslation(files3) {
    if (files3.length === 0) {
      return "";
    }
    let output = `### ${files3[0].reference.path}
`;
    for (const file of files3) {
      output += `@@@ ${file.path}
`;
      for (const key of file.additions) {
        output += `+++ ${key}
`;
      }
      for (const key of file.substractions) {
        output += `--- ${key}
`;
      }
    }
    return output;
  }
  async function deserializeComparedTranslations(input) {
    const compared = [];
    let reference = null;
    let current = null;
    for (const line of input.split("\n")) {
      const prefix = line.substr(0, 3);
      const value = line.substr(4);
      switch (prefix) {
        case "###":
          reference = await loadTranslation(value);
          break;
        case "@@@":
          const data = await fs_extra2.readJson(value);
          current = new ComparedTranslationFile(value, data);
          current.reference = reference;
          compared.push(current);
          break;
        case "+++":
          current.additions.push(value);
          break;
        case "---":
          current.substractions.push(value);
          break;
      }
    }
    return compared;
  }
  function compareTranslation(reference, file) {
    const compared = new ComparedTranslationFile(file.path, file.data);
    compared.reference = reference;
    compared.additions = file.keys.filter((key) => !reference.keys.includes(key));
    compared.substractions = reference.keys.filter((key) => !file.keys.includes(key));
    return compared;
  }
  function addTranslationKey(data, key, value) {
    if (!data) {
      return false;
    }
    if (!key.includes(".")) {
      if (!data[key]) {
        data[key] = value;
        return true;
      }
      return false;
    }
    const [firstkey, ...otherKeys] = key.split(".");
    if (!data[firstkey]) {
      data[firstkey] = {};
    }
    return addTranslationKey(data[firstkey], otherKeys.join("."), value);
  }
  function deleteTranslationKey(data, key) {
    if (!data) {
      return false;
    }
    if (!key.includes(".")) {
      if (data[key]) {
        delete data[key];
        return true;
      }
      return false;
    }
    const [firstkey, ...otherKeys] = key.split(".");
    return deleteTranslationKey(data[firstkey], otherKeys.join("."));
  }
  function getTranslationValue(data, path5) {
    return path5.split(".").reduce((data2, key) => data2 && data2[key] || null, data);
  }
  function sortTranslation(data) {
    return Object.keys(data).sort().reduce((sorted, key) => {
      if (typeof data[key] === "string") {
        sorted[key] = data[key];
      } else {
        sorted[key] = sortTranslation(data[key]);
      }
      return sorted;
    }, {});
  }
  function getTranslationKeys(data) {
    return getKeys(data);
  }
  function getLocale(path5) {
    return path.basename(path5).substr(0, 2);
  }

  // src/check/check.command.ts
  class CheckCommand {
    constructor(checker2) {
      this.checker = checker2;
    }
    async run(output, sourcesGlob, translationsGlob) {
      const sources = await loadFiles(sourcesGlob);
      const translations9 = await loadTranslations(translationsGlob);
      const unused = await this.checker.check(translations9, sources);
      await write(output, serializeKeys(unused));
    }
  }

  // src/check/checker.ts
  const events = __toModule(require("events"));
  class Checker extends events.EventEmitter {
    async check(translations9, sources) {
      const unused = [];
      const keys4 = getAllKeys(translations9);
      this.emit("checking", {keys: keys4, sources, translations: translations9});
      for (const key of keys4) {
        const source = findUsage(key, sources);
        if (source) {
          this.emit("used", {key, source});
        } else {
          unused.push(key);
          this.emit("unused", {key, sources});
        }
      }
      this.emit("checked", {unused});
      return unused;
    }
  }
  function getAllKeys(translations9) {
    return [...new Set(translations9.map((t) => t.keys).flat(1))];
  }
  function findUsage(key, sources) {
    return sources.find((file) => file.content.match(new RegExp(key)));
  }

  // src/clean/clean.command.ts
  class CleanCommand {
    constructor(cleaner2) {
      this.cleaner = cleaner2;
    }
    async run(input, translationsGlob) {
      const keys4 = deserializeKeys(await read(input));
      const translations9 = await loadTranslations(translationsGlob);
      const cleaned = await this.cleaner.clean(keys4, translations9);
      await Promise.all(cleaned.map((file) => saveTranslation(file)));
    }
  }

  // src/clean/cleaner.ts
  const events2 = __toModule(require("events"));
  class Cleaner extends events2.EventEmitter {
    async clean(keys4, translations9) {
      this.emit("cleaning", {keys: keys4, translations: translations9});
      for (const file of translations9) {
        for (const key of keys4) {
          if (file.delete(key)) {
            this.emit("removed", {key, file});
          } else {
            this.emit("passed", {key, file});
          }
        }
      }
      this.emit("cleaned", {keys: keys4, translations: translations9});
      return translations9;
    }
  }

  // src/compare/compare.command.ts
  class CompareCommand {
    constructor(comparer2) {
      this.comparer = comparer2;
    }
    async run(output, referencePath, translationsGlob) {
      const reference = await loadTranslation(referencePath);
      const translations9 = await loadTranslations(translationsGlob);
      const compared = await this.comparer.compare(reference, translations9);
      await write(output, serializeComparedTranslation(compared));
    }
  }

  // src/compare/comparer.ts
  const events3 = __toModule(require("events"));
  class Comparer extends events3.EventEmitter {
    async compare(reference, translations9) {
      const compared = [];
      this.emit("comparing", {reference, translations: translations9});
      for (const file of translations9) {
        const diffed = compareTranslation(reference, file);
        compared.push(diffed);
        this.emit("diff", {file: diffed});
      }
      this.emit("compared", {reference, translations: compared});
      return compared;
    }
  }

  // src/complete/complete.command.ts
  class CompleteCommand {
    constructor(completer2) {
      this.completer = completer2;
    }
    async run(input) {
      const diff = await deserializeComparedTranslations(await read(input));
      const completed = await this.completer.complete(diff);
    }
  }

  // src/complete/completer.ts
  const events4 = __toModule(require("events"));
  class Completer extends events4.EventEmitter {
    constructor(translator2) {
      super();
      this.translator = translator2;
    }
    async complete(translations9) {
      if (translations9.length === 0) {
        return translations9;
      }
      this.emit("completing", {reference: translations9[0].reference, translations: translations9});
      for (const file of translations9) {
        if (file.reference.path === file.path) {
          continue;
        }
        const originals = file.substractions.map((key) => file.reference.get(key));
        const translations10 = await this.translator.translate(file.reference.locale, file.locale, originals);
        for (const i in file.substractions) {
          const key = file.substractions[i];
          const original = originals[i];
          const translated = translations10[i];
          if (file.add(key, translated)) {
            this.emit("added", {file, key, original, translated});
          } else {
            this.emit("passed", {file, key, original, translated});
          }
        }
      }
      await Promise.all(translations9.map((file) => file.save()));
      this.emit("completed", {reference: translations9[0].reference, translations: translations9});
      return translations9;
    }
  }

  // src/config/index.ts
  const path2 = __toModule(require("path"));

  // src/config/config.ts
  const deepmerge = __toModule(require("deepmerge"));
  const fs_extra3 = __toModule(require("fs-extra"));
  class Config {
    constructor(path5, defaults) {
      this.path = path5;
      this.defaults = defaults;
      this.load();
      this.save();
    }
    get(key) {
      if (!this.hasKey(key)) {
        throw new Error(`Key "${key}" doesn't exist`);
      }
      return key.split(".").reduce((data, key2) => data && data[key2], this.data);
    }
    set(key, value) {
      if (!this.hasKey(key)) {
        throw new Error(`Key "${key}" doesn't exist`);
      }
      const keys4 = key.split(".");
      const last = keys4.pop();
      const next = {};
      const parent = keys4.reduce((data, key2) => data[key2] || (data[key2] = {}), next);
      parent[last] = value;
      this.data = deepmerge.default(this.data, next);
    }
    keys() {
      return getKeys(this.data);
    }
    has(key) {
      return !!this.get(key);
    }
    hasKey(key) {
      return this.keys().includes(key);
    }
    save() {
      fs_extra3.outputJsonSync(this.path, this.data, {spaces: 2});
    }
    load() {
      if (!fs_extra3.existsSync(this.path)) {
        this.data = this.defaults;
        return;
      }
      this.data = deepmerge.default(this.defaults, fs_extra3.readJsonSync(this.path));
    }
  }

  // src/config/index.ts
  const HOME_DIR = process.platform === "win32" ? process.env.USERPROFILE : process.env.HOME;
  const PATH = path2.join(HOME_DIR, ".lukos", "config.json");
  const DEFAULTS = {
    translate: {
      google: {
        serviceAccount: null
      }
    }
  };
  const config2 = new Config(PATH, DEFAULTS);

  // src/config/config.command.ts
  class ConfigCommand {
    async run(output, key, value) {
      if (value) {
        config2.set(key, value);
        config2.save();
        return;
      }
      value = config2.get(key);
      if (!value || typeof value === "object") {
        return;
      }
      await write(output, `${value}
`);
    }
  }

  // src/format/format.command.ts
  class FormatCommand {
    async run(translationsGlob) {
      await saveTranslations(await loadTranslations(translationsGlob));
    }
  }

  // src/pick/pick.ts
  function pick(keys4, translations9) {
    const picked = {};
    keys4.forEach((key) => {
      picked[key] = {};
      translations9.forEach((translation) => {
        picked[key][translation.path] = translation.get(key);
      });
    });
    return picked;
  }

  // src/pick/pick.command.ts
  class PickCommand {
    async run(input, output, translationsGlob) {
      const keys4 = deserializeKeys(await read(input));
      const translations9 = await loadTranslations(translationsGlob);
      const picked = pick(keys4, translations9);
      await write(output, JSON.stringify(picked, null, 2));
    }
  }

  // src/translate/translate.command.ts
  const fs_extra4 = __toModule(require("fs-extra"));
  const path3 = __toModule(require("path"));

  // src/translate/noop.translator.ts
  class NoopTranslator {
    translate(source, target, contents) {
      return Promise.resolve(contents);
    }
  }

  // src/translate/translate.command.ts
  class TranslateCommand {
    constructor(translator2) {
      this.translator = translator2;
    }
    async run(sourcePath, targetLocale) {
      if (this.translator instanceof NoopTranslator) {
        throw new Error(`The translate command requires a configured translation API.`);
      }
      const source = await loadTranslation(sourcePath);
      if (source.locale === targetLocale) {
        throw new Error("The source and target locales are the same.");
      }
      const targetPath = path3.join(path3.dirname(sourcePath), `${targetLocale}.json`);
      if (fs_extra4.existsSync(targetPath)) {
        throw new Error(`The target file "${targetPath}" already exists.`);
      }
      const targetFile = new TranslationFile(targetPath, {});
      const originals = source.keys.map((key) => source.get(key));
      const translations9 = await this.translator.translate(source.locale, targetLocale, originals);
      for (const i in source.keys) {
        const key = source.keys[i];
        const value = translations9[i];
        targetFile.add(key, value);
      }
      targetFile.save();
    }
  }

  // src/translate/google.translator.ts
  const v3 = __toModule(require("@google-cloud/translate/build/src/v3"));
  const fs_extra5 = __toModule(require("fs-extra"));
  class GoogleTranslator {
    constructor(serviceAccount) {
      process.env.GOOGLE_APPLICATION_CREDENTIALS = serviceAccount;
      this.client = new v3.TranslationServiceClient();
    }
    async translate(source, target, contents) {
      if (source === target) {
        return contents;
      }
      const credentials = await fs_extra5.readJson(process.env.GOOGLE_APPLICATION_CREDENTIALS);
      const request = {
        contents,
        sourceLanguageCode: source,
        targetLanguageCode: target,
        parent: `projects/${credentials.project_id}`,
        mimeType: "text/plain"
      };
      const [response] = await this.client.translateText(request);
      return response.translations.map((t) => t.translatedText);
    }
  }

  // src/translate/translator.factory.ts
  function createTranslator() {
    const serviceAccount = config2.get("translate.google.serviceAccount");
    if (serviceAccount) {
      return new GoogleTranslator(serviceAccount);
    }
    return new NoopTranslator();
  }

  // src/cli.ts
  commander.program.version(fs_extra6.readJsonSync(path4.join(__dirname, "..", "package.json")).version);
  commander.program.command("check <translations> <sources>").description("Checks if translations are used and output unused translation keys.", {
    translations: "Glob of the translation files (use quotes!)",
    sources: "Glob of the files where to find translation keys (use quotes!)"
  }).addHelpText("after", "Note that will only search for keys **AS IS**, and it's not able to resolve dynamically created keys.").action(async ({args}) => {
    const checker2 = new Checker().on("checking", ({keys: keys4, sources}) => console.error(`Checking ${keys4.length} keys in ${sources.length} files...`)).on("checked", ({unused}) => console.error(`Found ${unused.length} unused keys`)).on("used", ({key, source}) => console.error(`${key} is used by ${source.path}`)).on("unused", ({key}) => console.error(`${key} is unused`));
    const command = new CheckCommand(checker2);
    await command.run(process.stdout, args.sources, args.translations);
  });
  commander.program.command("clean <translations>").description("Removes unused items from translation files", {
    translations: "Glob of the translation files (use quotes!)"
  }).addHelpText("after", "Always double check your unused keys before running the command.").action(async ({args}) => {
    const cleaner2 = new Cleaner().on("cleaning", ({keys: keys4, translations: translations9}) => console.error(`Removing ${keys4.length} keys from ${translations9.length} files...`)).on("removed", ({key, file}) => console.error(`Removed "${key}" from "${file.path}".`)).on("passed", ({key, file}) => console.error(`Passed "${key}" from "${file.path}".`));
    const command = new CleanCommand(cleaner2);
    await command.run(process.stdin, args.translations);
  });
  commander.program.command("compare <reference> <translations>").description("Compare files with a reference file", {
    reference: "Path to the reference file",
    translations: "Glob of the translation files to compare (use quotes!)"
  }).action(async ({args}) => {
    const comparer2 = new Comparer().on("comparing", ({reference, translations: translations9}) => console.error(`Comparing ${reference.path} with ${translations9.length} files...`)).on("diff", ({file}) => console.error(`${file.path} +${file.additions.length} -${file.substractions.length}`));
    const command = new CompareCommand(comparer2);
    await command.run(process.stdout, args.reference, args.translations);
  });
  commander.program.command("complete", "Completes missing keys from a reference file").action(async ({args}) => {
    const completer2 = new Completer(createTranslator()).on("completing", ({reference, translations: translations9}) => console.error(`Completing ${translations9.length} files with values of ${reference.path}...`)).on("added", ({file, key}) => console.error(`Added ${key} in ${file.path}`)).on("passed", ({file, key}) => console.error(`Passed ${key} in ${file.path}`));
    const command = new CompleteCommand(completer2);
    await command.run(process.stdin);
  });
  commander.program.command("config <key> [value]").description("Get or set a config value", {
    key: "The config key to get or set",
    value: "The config value to set"
  }).action(async ({args}) => {
    try {
      await new ConfigCommand().run(process.stdout, args.key, args.value);
    } catch (error) {
      console.error(`Error: ${error.message} in ${error.fileName} at ${error.lineNumber}`, error.stack);
    }
  });
  commander.program.command("format <translations>").description("Sort keys and format of your JSON translation files", {
    translations: "Glob of the translation files to compare (use quotes!)"
  }).action(async ({args}) => {
    const command = new FormatCommand();
    await command.run(args.translations);
  });
  commander.program.command("pick <translations>").description("Finds key values in all translation files", {
    translations: "Glob of the translation files to compare (use quotes!)"
  }).action(async ({args}) => {
    const command = new PickCommand();
    await command.run(process.stdin, process.stdout, args.translations);
  });
  commander.program.command("translate <source> <locale>").description("Translate a source file into a new language", {
    source: "Path to the source file",
    locale: "Locale of the target language"
  }).action(async ({args}) => {
    const command = new TranslateCommand(createTranslator());
    await command.run(args.source, args.locale);
  });
  commander.program.parseAsync();
})();
