#!/usr/bin/env node
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 10);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.compareTranslation = exports.deserializeComparedTranslations = exports.serializeComparedTranslation = exports.loadTranslations = exports.loadTranslation = exports.saveTranslations = exports.saveTranslation = exports.ComparedTranslationFile = exports.TranslationFile = void 0;
const fs_extra_1 = __webpack_require__(1);
const path_1 = __webpack_require__(3);
const files_1 = __webpack_require__(6);
const objects_1 = __webpack_require__(7);
class TranslationFile {
    constructor(path, data) {
        this.path = path;
        this.data = data;
        this._keys = null;
    }
    get locale() {
        return getLocale(this.path);
    }
    get keys() {
        if (this._keys === null) {
            this._keys = getTranslationKeys(this.data);
        }
        return this._keys;
    }
    get(key) {
        return getTranslationValue(this.data, key);
    }
    add(key, value) {
        if (this._keys) {
            this._keys.push(key);
        }
        return addTranslationKey(this.data, key, value);
    }
    delete(key) {
        if (this._keys) {
            this._keys = this._keys.filter(k => k !== key);
        }
        return deleteTranslationKey(this.data, key);
    }
    save() {
        return saveTranslation(this);
    }
}
exports.TranslationFile = TranslationFile;
class ComparedTranslationFile extends TranslationFile {
    constructor() {
        super(...arguments);
        this.additions = [];
        this.substractions = [];
    }
}
exports.ComparedTranslationFile = ComparedTranslationFile;
function saveTranslation(file) {
    return __awaiter(this, void 0, void 0, function* () {
        yield fs_extra_1.writeJson(file.path, sortTranslation(file.data), { spaces: 2 });
    });
}
exports.saveTranslation = saveTranslation;
function saveTranslations(files) {
    return __awaiter(this, void 0, void 0, function* () {
        yield Promise.all(files.map(t => saveTranslation(t)));
    });
}
exports.saveTranslations = saveTranslations;
function loadTranslation(path) {
    return __awaiter(this, void 0, void 0, function* () {
        const data = yield fs_extra_1.readJson(path);
        return new TranslationFile(path, data);
    });
}
exports.loadTranslation = loadTranslation;
function loadTranslations(pattern) {
    return __awaiter(this, void 0, void 0, function* () {
        const paths = yield files_1.resolvePattern(pattern);
        return Promise.all(paths.map(path => loadTranslation(path)));
    });
}
exports.loadTranslations = loadTranslations;
function serializeComparedTranslation(files) {
    if (files.length === 0) {
        return '';
    }
    let output = `### ${files[0].reference.path}\n`;
    for (const file of files) {
        output += `@@@ ${file.path}\n`;
        for (const key of file.additions) {
            output += `+++ ${key}\n`;
        }
        for (const key of file.substractions) {
            output += `--- ${key}\n`;
        }
    }
    return output;
}
exports.serializeComparedTranslation = serializeComparedTranslation;
function deserializeComparedTranslations(input) {
    return __awaiter(this, void 0, void 0, function* () {
        const compared = [];
        let reference = null;
        let current = null;
        for (const line of input.split('\n')) {
            const prefix = line.substr(0, 3);
            const value = line.substr(4);
            switch (prefix) {
                case '###':
                    reference = yield loadTranslation(value);
                    break;
                case '@@@':
                    const data = yield fs_extra_1.readJson(value);
                    current = new ComparedTranslationFile(value, data);
                    current.reference = reference;
                    compared.push(current);
                    break;
                case '+++':
                    current.additions.push(value);
                    break;
                case '---':
                    current.substractions.push(value);
                    break;
            }
        }
        return compared;
    });
}
exports.deserializeComparedTranslations = deserializeComparedTranslations;
function compareTranslation(reference, file) {
    const compared = new ComparedTranslationFile(file.path, file.data);
    compared.reference = reference;
    compared.additions = file.keys.filter(key => !reference.keys.includes(key));
    compared.substractions = reference.keys.filter(key => !file.keys.includes(key));
    return compared;
}
exports.compareTranslation = compareTranslation;
function addTranslationKey(data, key, value) {
    if (!data) {
        return false;
    }
    if (!key.includes('.')) {
        if (!data[key]) {
            data[key] = value;
            return true;
        }
        return false;
    }
    const [firstkey, ...otherKeys] = key.split('.');
    if (!data[firstkey]) {
        data[firstkey] = {};
    }
    return addTranslationKey(data[firstkey], otherKeys.join('.'), value);
}
function deleteTranslationKey(data, key) {
    if (!data) {
        return false;
    }
    if (!key.includes('.')) {
        if (data[key]) {
            delete data[key];
            return true;
        }
        return false;
    }
    const [firstkey, ...otherKeys] = key.split('.');
    return deleteTranslationKey(data[firstkey], otherKeys.join('.'));
}
function getTranslationValue(data, path) {
    return path.split('.').reduce((data, key) => (data && data[key]) || null, data);
}
function sortTranslation(data) {
    return Object.keys(data)
        .sort()
        .reduce((sorted, key) => {
        if (typeof data[key] === 'string') {
            sorted[key] = data[key];
        }
        else {
            sorted[key] = sortTranslation(data[key]);
        }
        return sorted;
    }, {});
}
function getTranslationKeys(data) {
    return objects_1.getKeys(data);
}
function getLocale(path) {
    return path_1.basename(path, '.json');
}


/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("fs-extra");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.write = exports.read = void 0;
function read(stream) {
    var stream_1, stream_1_1;
    var e_1, _a;
    return __awaiter(this, void 0, void 0, function* () {
        const chunks = [];
        try {
            for (stream_1 = __asyncValues(stream); stream_1_1 = yield stream_1.next(), !stream_1_1.done;) {
                const chunk = stream_1_1.value;
                chunks.push(chunk);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (stream_1_1 && !stream_1_1.done && (_a = stream_1.return)) yield _a.call(stream_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return Buffer.concat(chunks).toString('utf8');
    });
}
exports.read = read;
function write(stream, data) {
    return new Promise(resolve => stream.write(data, 'utf8', () => resolve()));
}
exports.write = write;


/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("events");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializeKeys = exports.serializeKeys = void 0;
function serializeKeys(keys) {
    return keys.join('\n') + '\n';
}
exports.serializeKeys = serializeKeys;
function deserializeKeys(content) {
    return content
        .split('\n')
        .map(k => k.trim())
        .filter(Boolean);
}
exports.deserializeKeys = deserializeKeys;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadFiles = exports.loadFile = exports.resolvePattern = void 0;
const fs_extra_1 = __webpack_require__(1);
const glob = __webpack_require__(13);
function resolvePattern(pattern) {
    return new Promise((resolve, reject) => glob(pattern, (error, matches) => (error ? reject(error) : resolve(matches))));
}
exports.resolvePattern = resolvePattern;
function loadFile(path) {
    return __awaiter(this, void 0, void 0, function* () {
        return {
            path,
            content: yield fs_extra_1.readFile(path, 'utf8'),
        };
    });
}
exports.loadFile = loadFile;
function loadFiles(pattern) {
    return __awaiter(this, void 0, void 0, function* () {
        const paths = yield resolvePattern(pattern);
        return Promise.all(paths.map(path => loadFile(path)));
    });
}
exports.loadFiles = loadFiles;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getKeys = void 0;
function getKeys(data, prefix = '') {
    return Object.keys(data).reduce((keys, key) => {
        if (!data[key] || typeof data[key] === 'string') {
            keys.push(prefix + key);
        }
        else {
            keys = [...keys, ...getKeys(data[key], prefix + key + '.')];
        }
        return keys;
    }, []);
}
exports.getKeys = getKeys;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.config = void 0;
const path_1 = __webpack_require__(3);
const config_1 = __webpack_require__(22);
const HOME_DIR = process.platform === 'win32' ? process.env.USERPROFILE : process.env.HOME;
const PATH = path_1.join(HOME_DIR, '.lukos', 'config.json');
const DEFAULTS = {
    translate: {
        google: {
            serviceAccount: null,
        },
    },
};
exports.config = new config_1.Config(PATH, DEFAULTS);


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NoopTranslator = void 0;
class NoopTranslator {
    translate(source, target, contents) {
        return Promise.resolve(contents);
    }
}
exports.NoopTranslator = NoopTranslator;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = __webpack_require__(11);
const fs_extra_1 = __webpack_require__(1);
const path_1 = __webpack_require__(3);
const check_command_1 = __webpack_require__(12);
const checker_1 = __webpack_require__(14);
const clean_command_1 = __webpack_require__(15);
const cleaner_1 = __webpack_require__(16);
const compare_command_1 = __webpack_require__(17);
const comparer_1 = __webpack_require__(18);
const complete_command_1 = __webpack_require__(19);
const completer_1 = __webpack_require__(20);
const config_command_1 = __webpack_require__(21);
const format_command_1 = __webpack_require__(24);
const pick_command_1 = __webpack_require__(25);
const translate_command_1 = __webpack_require__(27);
const translator_factory_1 = __webpack_require__(28);
core_1.program.version(fs_extra_1.readJsonSync(path_1.join(__dirname, '..', 'package.json')).version);
core_1.program
    .command('check', 'Checks if translations are used and output unused translation keys.')
    .help("Note that will it only search for keys **AS IS**, and it's not able to resolve dynamically created keys.")
    .argument('<translations>', 'Glob of the translation files (use quotes!)')
    .argument('<sources>', 'Glob of the files where to find translation keys (use quotes!)')
    .action(({ args }) => __awaiter(void 0, void 0, void 0, function* () {
    const checker = new checker_1.Checker()
        .on('checking', ({ keys, sources }) => console.error(`Checking ${keys.length} keys in ${sources.length} files...`))
        .on('checked', ({ unused }) => console.error(`Found ${unused.length} unused keys`))
        .on('used', ({ key, source }) => console.error(`${key} is used by ${source.path}`))
        .on('unused', ({ key }) => console.error(`${key} is unused`));
    const command = new check_command_1.CheckCommand(checker);
    yield command.run(process.stdout, args.sources, args.translations);
}));
core_1.program
    .command('clean', 'Removes unused items from translation files')
    .help('Always double check your unused keys before running the command.')
    .argument('<translations>', 'Glob of the translation files (use quotes!)')
    .action(({ args }) => __awaiter(void 0, void 0, void 0, function* () {
    const cleaner = new cleaner_1.Cleaner()
        .on('cleaning', ({ keys, translations }) => console.error(`Removing ${keys.length} keys from ${translations.length} files...`))
        .on('removed', ({ key, file }) => console.error(`Removed "${key}" from "${file.path}".`))
        .on('passed', ({ key, file }) => console.error(`Passed "${key}" from "${file.path}".`));
    const command = new clean_command_1.CleanCommand(cleaner);
    yield command.run(process.stdin, args.translations);
}));
core_1.program
    .command('compare', 'Compare files with a reference file')
    .argument('<reference>', 'Path to the reference file')
    .argument('<translations>', 'Glob of the translation files to compare (use quotes!)')
    .action(({ args }) => __awaiter(void 0, void 0, void 0, function* () {
    const comparer = new comparer_1.Comparer()
        .on('comparing', ({ reference, translations }) => console.error(`Comparing ${reference.path} with ${translations.length} files...`))
        .on('diff', ({ file }) => console.error(`${file.path} +${file.additions.length} -${file.substractions.length}`));
    const command = new compare_command_1.CompareCommand(comparer);
    yield command.run(process.stdout, args.reference, args.translations);
}));
core_1.program.command('complete', 'Completes missing keys from a reference file').action(({ args }) => __awaiter(void 0, void 0, void 0, function* () {
    const completer = new completer_1.Completer(translator_factory_1.createTranslator())
        .on('completing', ({ reference, translations }) => console.error(`Completing ${translations.length} files with values of ${reference.path}...`))
        .on('added', ({ file, key }) => console.error(`Added ${key} in ${file.path}`))
        .on('passed', ({ file, key }) => console.error(`Passed ${key} in ${file.path}`));
    const command = new complete_command_1.CompleteCommand(completer);
    yield command.run(process.stdin);
}));
core_1.program
    .command('config', 'Get or set a config value')
    .argument('<key>', 'The config key to get or set')
    .argument('[value]', 'The config value to set')
    .action(({ args }) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        yield new config_command_1.ConfigCommand().run(process.stdout, args.key, args.value);
    }
    catch (error) {
        console.error(`Error: ${error.message} in ${error.fileName} at ${error.lineNumber}`, error.stack);
    }
}));
core_1.program
    .command('format', 'Sort keys and format of your JSON translation files')
    .argument('<translations>', 'Glob of the translation files to compare (use quotes!)')
    .action(({ args }) => __awaiter(void 0, void 0, void 0, function* () {
    const command = new format_command_1.FormatCommand();
    yield command.run(args.translations);
}));
core_1.program
    .command('pick', 'Finds key values in all translation files')
    .argument('<translations>', 'Glob of the translation files to compare (use quotes!)')
    .action(({ args }) => __awaiter(void 0, void 0, void 0, function* () {
    const command = new pick_command_1.PickCommand();
    yield command.run(process.stdin, process.stdout, args.translations);
}));
core_1.program
    .command('translate', 'Translate a source file into a new language')
    .argument('<source>', 'Path to the source file')
    .argument('<locale>', 'Locale of the target language')
    .action(({ args }) => __awaiter(void 0, void 0, void 0, function* () {
    const command = new translate_command_1.TranslateCommand(translator_factory_1.createTranslator());
    yield command.run(args.source, args.locale);
}));
core_1.program.run();


/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = require("@caporal/core");

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CheckCommand = void 0;
const files_1 = __webpack_require__(6);
const keys_1 = __webpack_require__(5);
const stream_1 = __webpack_require__(2);
const translations_1 = __webpack_require__(0);
class CheckCommand {
    constructor(checker) {
        this.checker = checker;
    }
    run(output, sourcesGlob, translationsGlob) {
        return __awaiter(this, void 0, void 0, function* () {
            const sources = yield files_1.loadFiles(sourcesGlob);
            const translations = yield translations_1.loadTranslations(translationsGlob);
            const unused = yield this.checker.check(translations, sources);
            yield stream_1.write(output, keys_1.serializeKeys(unused));
        });
    }
}
exports.CheckCommand = CheckCommand;


/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = require("glob");

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Checker = void 0;
const events_1 = __webpack_require__(4);
class Checker extends events_1.EventEmitter {
    check(translations, sources) {
        return __awaiter(this, void 0, void 0, function* () {
            const unused = [];
            const keys = getAllKeys(translations);
            this.emit('checking', { keys, sources, translations });
            for (const key of keys) {
                const source = findUsage(key, sources);
                if (source) {
                    this.emit('used', { key, source });
                }
                else {
                    unused.push(key);
                    this.emit('unused', { key, sources });
                }
            }
            this.emit('checked', { unused });
            return unused;
        });
    }
}
exports.Checker = Checker;
function getAllKeys(translations) {
    return [...new Set(translations.map(t => t.keys).flat(1))];
}
function findUsage(key, sources) {
    return sources.find(file => file.content.match(new RegExp(key)));
}


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CleanCommand = void 0;
const keys_1 = __webpack_require__(5);
const stream_1 = __webpack_require__(2);
const translations_1 = __webpack_require__(0);
class CleanCommand {
    constructor(cleaner) {
        this.cleaner = cleaner;
    }
    run(input, translationsGlob) {
        return __awaiter(this, void 0, void 0, function* () {
            const keys = keys_1.deserializeKeys(yield stream_1.read(input));
            const translations = yield translations_1.loadTranslations(translationsGlob);
            const cleaned = yield this.cleaner.clean(keys, translations);
            yield Promise.all(cleaned.map(file => translations_1.saveTranslation(file)));
        });
    }
}
exports.CleanCommand = CleanCommand;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cleaner = void 0;
const events_1 = __webpack_require__(4);
class Cleaner extends events_1.EventEmitter {
    clean(keys, translations) {
        return __awaiter(this, void 0, void 0, function* () {
            this.emit('cleaning', { keys, translations });
            for (const file of translations) {
                for (const key of keys) {
                    if (file.delete(key)) {
                        this.emit('removed', { key, file });
                    }
                    else {
                        this.emit('passed', { key, file });
                    }
                }
            }
            this.emit('cleaned', { keys, translations });
            return translations;
        });
    }
}
exports.Cleaner = Cleaner;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompareCommand = void 0;
const stream_1 = __webpack_require__(2);
const translations_1 = __webpack_require__(0);
class CompareCommand {
    constructor(comparer) {
        this.comparer = comparer;
    }
    run(output, referencePath, translationsGlob) {
        return __awaiter(this, void 0, void 0, function* () {
            const reference = yield translations_1.loadTranslation(referencePath);
            const translations = yield translations_1.loadTranslations(translationsGlob);
            const compared = yield this.comparer.compare(reference, translations);
            yield stream_1.write(output, translations_1.serializeComparedTranslation(compared));
        });
    }
}
exports.CompareCommand = CompareCommand;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Comparer = void 0;
const events_1 = __webpack_require__(4);
const translations_1 = __webpack_require__(0);
class Comparer extends events_1.EventEmitter {
    compare(reference, translations) {
        return __awaiter(this, void 0, void 0, function* () {
            const compared = [];
            this.emit('comparing', { reference, translations });
            for (const file of translations) {
                const diffed = translations_1.compareTranslation(reference, file);
                compared.push(diffed);
                this.emit('diff', { file: diffed });
            }
            this.emit('compared', { reference, translations: compared });
            return compared;
        });
    }
}
exports.Comparer = Comparer;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompleteCommand = void 0;
const stream_1 = __webpack_require__(2);
const translations_1 = __webpack_require__(0);
class CompleteCommand {
    constructor(completer) {
        this.completer = completer;
    }
    run(input) {
        return __awaiter(this, void 0, void 0, function* () {
            const diff = yield translations_1.deserializeComparedTranslations(yield stream_1.read(input));
            const completed = yield this.completer.complete(diff);
        });
    }
}
exports.CompleteCommand = CompleteCommand;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Completer = void 0;
const events_1 = __webpack_require__(4);
class Completer extends events_1.EventEmitter {
    constructor(translator) {
        super();
        this.translator = translator;
    }
    complete(translations) {
        return __awaiter(this, void 0, void 0, function* () {
            if (translations.length === 0) {
                return translations;
            }
            this.emit('completing', { reference: translations[0].reference, translations });
            for (const file of translations) {
                if (file.reference.path === file.path) {
                    continue;
                }
                const originals = file.substractions.map(key => file.reference.get(key));
                const translations = yield this.translator.translate(file.reference.locale, file.locale, originals);
                for (const i in file.substractions) {
                    const key = file.substractions[i];
                    const original = originals[i];
                    const translated = translations[i];
                    if (file.add(key, translated)) {
                        this.emit('added', { file, key, original, translated });
                    }
                    else {
                        this.emit('passed', { file, key, original, translated });
                    }
                }
            }
            yield Promise.all(translations.map(file => file.save()));
            this.emit('completed', { reference: translations[0].reference, translations });
            return translations;
        });
    }
}
exports.Completer = Completer;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigCommand = void 0;
const _1 = __webpack_require__(8);
const stream_1 = __webpack_require__(2);
class ConfigCommand {
    run(output, key, value) {
        return __awaiter(this, void 0, void 0, function* () {
            if (value) {
                _1.config.set(key, value);
                _1.config.save();
                return;
            }
            value = _1.config.get(key);
            if (!value || typeof value === 'object') {
                return;
            }
            yield stream_1.write(output, `${value}\n`);
        });
    }
}
exports.ConfigCommand = ConfigCommand;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Config = void 0;
const merge = __webpack_require__(23);
const fs_extra_1 = __webpack_require__(1);
const objects_1 = __webpack_require__(7);
class Config {
    constructor(path, defaults) {
        this.path = path;
        this.defaults = defaults;
        this.load();
        this.save();
    }
    get(key) {
        if (!this.hasKey(key)) {
            throw new Error(`Key "${key}" doesn't exist`);
        }
        return key.split('.').reduce((data, key) => data && data[key], this.data);
    }
    set(key, value) {
        if (!this.hasKey(key)) {
            throw new Error(`Key "${key}" doesn't exist`);
        }
        const keys = key.split('.');
        const last = keys.pop();
        const next = {};
        const parent = keys.reduce((data, key) => data[key] || (data[key] = {}), next);
        parent[last] = value;
        this.data = merge(this.data, next);
    }
    keys() {
        return objects_1.getKeys(this.data);
    }
    has(key) {
        return !!this.get(key);
    }
    hasKey(key) {
        return this.keys().includes(key);
    }
    save() {
        fs_extra_1.outputJsonSync(this.path, this.data, { spaces: 2 });
    }
    load() {
        if (!fs_extra_1.existsSync(this.path)) {
            this.data = this.defaults;
            return;
        }
        this.data = merge(this.defaults, fs_extra_1.readJsonSync(this.path));
    }
}
exports.Config = Config;


/***/ }),
/* 23 */
/***/ (function(module, exports) {

module.exports = require("deepmerge");

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FormatCommand = void 0;
const translations_1 = __webpack_require__(0);
class FormatCommand {
    run(translationsGlob) {
        return __awaiter(this, void 0, void 0, function* () {
            yield translations_1.saveTranslations(yield translations_1.loadTranslations(translationsGlob));
        });
    }
}
exports.FormatCommand = FormatCommand;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PickCommand = void 0;
const keys_1 = __webpack_require__(5);
const stream_1 = __webpack_require__(2);
const translations_1 = __webpack_require__(0);
const pick_1 = __webpack_require__(26);
class PickCommand {
    run(input, output, translationsGlob) {
        return __awaiter(this, void 0, void 0, function* () {
            const keys = keys_1.deserializeKeys(yield stream_1.read(input));
            const translations = yield translations_1.loadTranslations(translationsGlob);
            const picked = pick_1.pick(keys, translations);
            yield stream_1.write(output, JSON.stringify(picked, null, 2));
        });
    }
}
exports.PickCommand = PickCommand;


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.pick = void 0;
function pick(keys, translations) {
    const picked = {};
    keys.forEach(key => {
        picked[key] = {};
        translations.forEach(translation => {
            picked[key][translation.path] = translation.get(key);
        });
    });
    return picked;
}
exports.pick = pick;


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TranslateCommand = void 0;
const fs_extra_1 = __webpack_require__(1);
const path_1 = __webpack_require__(3);
const translations_1 = __webpack_require__(0);
const noop_translator_1 = __webpack_require__(9);
class TranslateCommand {
    constructor(translator) {
        this.translator = translator;
    }
    run(sourcePath, targetLocale) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.translator instanceof noop_translator_1.NoopTranslator) {
                throw new Error(`The translate command requires a configured translation API.`);
            }
            const source = yield translations_1.loadTranslation(sourcePath);
            if (source.locale === targetLocale) {
                throw new Error('The source and target locales are the same.');
            }
            const targetPath = path_1.join(path_1.dirname(sourcePath), `${targetLocale}.json`);
            if (fs_extra_1.existsSync(targetPath)) {
                throw new Error(`The target file "${targetPath}" already exists.`);
            }
            const targetFile = new translations_1.TranslationFile(targetPath, {});
            const originals = source.keys.map(key => source.get(key));
            const translations = yield this.translator.translate(source.locale, targetLocale, originals);
            for (const i in source.keys) {
                const key = source.keys[i];
                const value = translations[i];
                targetFile.add(key, value);
            }
            targetFile.save();
        });
    }
}
exports.TranslateCommand = TranslateCommand;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.createTranslator = void 0;
const config_1 = __webpack_require__(8);
const google_translator_1 = __webpack_require__(29);
const noop_translator_1 = __webpack_require__(9);
function createTranslator() {
    const serviceAccount = config_1.config.get('translate.google.serviceAccount');
    if (serviceAccount) {
        return new google_translator_1.GoogleTranslator(serviceAccount);
    }
    return new noop_translator_1.NoopTranslator();
}
exports.createTranslator = createTranslator;


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GoogleTranslator = void 0;
const v3_1 = __webpack_require__(30);
const fs_extra_1 = __webpack_require__(1);
class GoogleTranslator {
    constructor(serviceAccount) {
        process.env.GOOGLE_APPLICATION_CREDENTIALS = serviceAccount;
        this.client = new v3_1.TranslationServiceClient();
    }
    translate(source, target, contents) {
        return __awaiter(this, void 0, void 0, function* () {
            if (source === target) {
                return contents;
            }
            const credentials = yield fs_extra_1.readJson(process.env.GOOGLE_APPLICATION_CREDENTIALS);
            const request = {
                contents,
                sourceLanguageCode: source,
                targetLanguageCode: target,
                parent: `projects/${credentials.project_id}`,
                mimeType: 'text/plain',
            };
            const [response] = yield this.client.translateText(request);
            return response.translations.map(t => t.translatedText);
        });
    }
}
exports.GoogleTranslator = GoogleTranslator;


/***/ }),
/* 30 */
/***/ (function(module, exports) {

module.exports = require("@google-cloud/translate/build/src/v3");

/***/ })
/******/ ]);