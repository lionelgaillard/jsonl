#!/usr/bin/env node
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 7);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTranslationValue = exports.deleteTranslationKey = exports.addTranslationKey = exports.compareTranslation = exports.deserializeComparedTranslations = exports.serializeComparedTranslation = exports.loadTranslations = exports.loadTranslation = exports.saveTranslations = exports.saveTranslation = void 0;
const fs_extra_1 = __webpack_require__(6);
const files_1 = __webpack_require__(5);
function saveTranslation(file) {
    return __awaiter(this, void 0, void 0, function* () {
        yield fs_extra_1.writeJson(file.path, sortTranslation(file.data), { spaces: 2 });
    });
}
exports.saveTranslation = saveTranslation;
function saveTranslations(files) {
    return __awaiter(this, void 0, void 0, function* () {
        yield Promise.all(files.map(t => saveTranslation(t)));
    });
}
exports.saveTranslations = saveTranslations;
function sortTranslation(data) {
    return Object.keys(data)
        .sort()
        .reduce((sorted, key) => {
        if (typeof data[key] === 'string') {
            sorted[key] = data[key];
        }
        else {
            sorted[key] = sortTranslation(data[key]);
        }
        return sorted;
    }, {});
}
function loadTranslation(path) {
    return __awaiter(this, void 0, void 0, function* () {
        const data = yield fs_extra_1.readJson(path);
        const keys = getTranslationKeys(data);
        return {
            path,
            data,
            keys,
        };
    });
}
exports.loadTranslation = loadTranslation;
function loadTranslations(pattern) {
    return __awaiter(this, void 0, void 0, function* () {
        const paths = yield files_1.resolvePattern(pattern);
        return Promise.all(paths.map(path => loadTranslation(path)));
    });
}
exports.loadTranslations = loadTranslations;
function serializeComparedTranslation(files) {
    return files.reduce((output, file) => {
        output += `@@@ ${file.path}\n`;
        if (file.additions.length > 0) {
            output += file.additions.map(key => `+++ ${key}`).join('\n') + '\n';
        }
        if (file.substractions.length > 0) {
            output += file.substractions.map(key => `--- ${key}`).join('\n') + '\n';
        }
        return output;
    }, '');
}
exports.serializeComparedTranslation = serializeComparedTranslation;
function deserializeComparedTranslations(input) {
    return __awaiter(this, void 0, void 0, function* () {
        const parts = input
            .split('@@@ ')
            .map(c => c.trim())
            .filter(Boolean);
        const compared = [];
        for (const part of parts) {
            const lines = part.split('\n');
            if (lines.length === 0) {
                continue;
            }
            const path = lines.shift();
            const file = yield loadTranslation(path);
            const additions = lines.filter(line => line.startsWith('+++ ')).map(line => line.substr(4));
            const substractions = lines.filter(line => line.startsWith('--- ')).map(line => line.substr(4));
            compared.push(Object.assign(Object.assign({}, file), { additions,
                substractions }));
        }
        return compared;
    });
}
exports.deserializeComparedTranslations = deserializeComparedTranslations;
function compareTranslation(reference, file) {
    return Object.assign(Object.assign({}, file), { additions: file.keys.filter(key => !reference.keys.includes(key)), substractions: reference.keys.filter(key => !file.keys.includes(key)) });
}
exports.compareTranslation = compareTranslation;
function getTranslationKeys(data, prefix = '') {
    return Object.keys(data).reduce((keys, key) => {
        if (typeof data[key] === 'string') {
            keys.push(prefix + key);
        }
        else {
            keys = [...keys, ...getTranslationKeys(data[key], prefix + key + '.')];
        }
        return keys;
    }, []);
}
function addTranslationKey(data, key, value) {
    if (!data) {
        return false;
    }
    if (!key.includes('.')) {
        if (!data[key]) {
            data[key] = value;
            return true;
        }
        return false;
    }
    const [firstkey, ...otherKeys] = key.split('.');
    if (!data[firstkey]) {
        data[firstkey] = {};
    }
    return addTranslationKey(data[firstkey], otherKeys.join('.'), value);
}
exports.addTranslationKey = addTranslationKey;
function deleteTranslationKey(data, key) {
    if (!data) {
        return false;
    }
    if (!key.includes('.')) {
        if (data[key]) {
            delete data[key];
            return true;
        }
        return false;
    }
    const [firstkey, ...otherKeys] = key.split('.');
    return deleteTranslationKey(data[firstkey], otherKeys.join('.'));
}
exports.deleteTranslationKey = deleteTranslationKey;
function getTranslationValue(data, path) {
    return path.split('.').reduce((data, key) => (data && data[key]) || null, data);
}
exports.getTranslationValue = getTranslationValue;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.write = exports.read = void 0;
function read(stream) {
    var stream_1, stream_1_1;
    var e_1, _a;
    return __awaiter(this, void 0, void 0, function* () {
        const chunks = [];
        try {
            for (stream_1 = __asyncValues(stream); stream_1_1 = yield stream_1.next(), !stream_1_1.done;) {
                const chunk = stream_1_1.value;
                chunks.push(chunk);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (stream_1_1 && !stream_1_1.done && (_a = stream_1.return)) yield _a.call(stream_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return Buffer.concat(chunks).toString('utf8');
    });
}
exports.read = read;
function write(stream, data) {
    return new Promise(resolve => stream.write(data, 'utf8', () => resolve()));
}
exports.write = write;


/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("events");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializeKeys = exports.serializeKeys = void 0;
function serializeKeys(keys) {
    return keys.join('\n') + '\n';
}
exports.serializeKeys = serializeKeys;
function deserializeKeys(content) {
    return content
        .split('\n')
        .map(k => k.trim())
        .filter(Boolean);
}
exports.deserializeKeys = deserializeKeys;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.tick = void 0;
function tick() {
    return new Promise(resolve => setImmediate(resolve));
}
exports.tick = tick;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadFiles = exports.loadFile = exports.resolvePattern = void 0;
const fs_extra_1 = __webpack_require__(6);
const glob = __webpack_require__(10);
function resolvePattern(pattern) {
    return new Promise((resolve, reject) => glob(pattern, (error, matches) => (error ? reject(error) : resolve(matches))));
}
exports.resolvePattern = resolvePattern;
function loadFile(path) {
    return __awaiter(this, void 0, void 0, function* () {
        return {
            path,
            content: yield fs_extra_1.readFile(path, 'utf8'),
        };
    });
}
exports.loadFile = loadFile;
function loadFiles(pattern) {
    return __awaiter(this, void 0, void 0, function* () {
        const paths = yield resolvePattern(pattern);
        return Promise.all(paths.map(path => loadFile(path)));
    });
}
exports.loadFiles = loadFiles;


/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("fs-extra");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = __webpack_require__(8);
const check_command_1 = __webpack_require__(9);
const checker_1 = __webpack_require__(11);
const clean_command_1 = __webpack_require__(12);
const cleaner_1 = __webpack_require__(13);
const compare_command_1 = __webpack_require__(14);
const comparer_1 = __webpack_require__(15);
const complete_command_1 = __webpack_require__(16);
const completer_1 = __webpack_require__(17);
const format_command_1 = __webpack_require__(18);
const pick_command_1 = __webpack_require__(19);
core_1.program
    .command('check', 'Checks if translations are used and output unused translation keys.')
    .help("Note that will it only search for keys **AS IS**, and it's not able to resolve dynamically created keys.")
    .argument('<translations>', 'Glob of the translation files (use quotes!)')
    .argument('<sources>', 'Glob of the files where to find translation keys (use quotes!)')
    .action(({ args }) => __awaiter(void 0, void 0, void 0, function* () {
    const checker = new checker_1.Checker()
        .on('checking', ({ keys, sources }) => console.error(`Checking ${keys.length} keys in ${sources.length} files...`))
        .on('checked', ({ unused }) => console.error(`Found ${unused.length} unused keys`))
        .on('used', ({ key, source }) => console.error(`${key} is used by ${source.path}`))
        .on('unused', ({ key }) => console.error(`${key} is unused`));
    const command = new check_command_1.CheckCommand(checker);
    yield command.run(process.stdout, args.sources, args.translations);
}));
core_1.program
    .command('clean', 'Removes unused items from translation files')
    .help('Always double check your unused keys before running the command.')
    .argument('<translations>', 'Glob of the translation files (use quotes!)')
    .action(({ args }) => __awaiter(void 0, void 0, void 0, function* () {
    const cleaner = new cleaner_1.Cleaner()
        .on('cleaning', ({ keys, translations }) => console.error(`Removing ${keys.length} keys from ${translations.length} files...`))
        .on('removed', ({ key, file }) => console.error(`Removed "${key}" from "${file.path}".`))
        .on('passed', ({ key, file }) => console.error(`Passed "${key}" from "${file.path}".`));
    const command = new clean_command_1.CleanCommand(cleaner);
    yield command.run(process.stdin, args.translations);
}));
core_1.program
    .command('compare', 'Compare files with a reference file')
    .argument('<reference>', 'Path to the reference file')
    .argument('<translations>', 'Glob of the translation files to compare (use quotes!)')
    .action(({ args }) => __awaiter(void 0, void 0, void 0, function* () {
    const comparer = new comparer_1.Comparer()
        .on('comparing', ({ reference, translations }) => console.error(`Comparing ${reference.path} with ${translations.length} files...`))
        .on('diff', ({ file }) => console.error(`${file.path} +${file.additions.length} -${file.substractions.length}`));
    const command = new compare_command_1.CompareCommand(comparer);
    yield command.run(process.stdout, args.reference, args.translations);
}));
core_1.program
    .command('complete', 'Completes missing keys from a reference file')
    .argument('<reference>', 'Path of the reference translation file')
    .action(({ args }) => __awaiter(void 0, void 0, void 0, function* () {
    const completer = new completer_1.Completer()
        .on('completing', ({ reference, translations }) => console.error(`Completing ${translations.length} files with values of ${reference.path}...`))
        .on('added', ({ file, key }) => console.error(`Added ${key} in ${file.path}`))
        .on('passed', ({ file, key }) => console.error(`Passed ${key} in ${file.path}`));
    const command = new complete_command_1.CompleteCommand(completer);
    yield command.run(process.stdin, args.reference);
}));
core_1.program
    .command('format', 'Sort keys and format of your JSON translation files')
    .argument('<translations>', 'Glob of the translation files to compare (use quotes!)')
    .action(({ args }) => __awaiter(void 0, void 0, void 0, function* () {
    const command = new format_command_1.FormatCommand();
    yield command.run(args.translations);
}));
core_1.program
    .command('pick', 'Finds key values in all translation files')
    .argument('<translations>', 'Glob of the translation files to compare (use quotes!)')
    .action(({ args }) => __awaiter(void 0, void 0, void 0, function* () {
    const command = new pick_command_1.PickCommand();
    yield command.run(process.stdin, process.stdout, args.translations);
}));
core_1.program.run();


/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = require("@caporal/core");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CheckCommand = void 0;
const files_1 = __webpack_require__(5);
const keys_1 = __webpack_require__(3);
const stream_1 = __webpack_require__(1);
const translations_1 = __webpack_require__(0);
class CheckCommand {
    constructor(checker) {
        this.checker = checker;
    }
    run(output, sourcesGlob, translationsGlob) {
        return __awaiter(this, void 0, void 0, function* () {
            const sources = yield files_1.loadFiles(sourcesGlob);
            const translations = yield translations_1.loadTranslations(translationsGlob);
            const unused = yield this.checker.check(translations, sources);
            yield stream_1.write(output, keys_1.serializeKeys(unused));
        });
    }
}
exports.CheckCommand = CheckCommand;


/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = require("glob");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Checker = void 0;
const events_1 = __webpack_require__(2);
class Checker extends events_1.EventEmitter {
    check(translations, sources) {
        return __awaiter(this, void 0, void 0, function* () {
            const unused = [];
            const keys = getAllKeys(translations);
            this.emit('checking', { keys, sources, translations });
            for (const key of keys) {
                const source = findUsage(key, sources);
                if (source) {
                    this.emit('used', { key, source });
                }
                else {
                    unused.push(key);
                    this.emit('unused', { key, sources });
                }
            }
            this.emit('checked', { unused });
            return unused;
        });
    }
}
exports.Checker = Checker;
function getAllKeys(translations) {
    return [...new Set(translations.map(t => t.keys).flat(1))];
}
function findUsage(key, sources) {
    return sources.find(file => file.content.match(new RegExp(key)));
}


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CleanCommand = void 0;
const keys_1 = __webpack_require__(3);
const stream_1 = __webpack_require__(1);
const translations_1 = __webpack_require__(0);
class CleanCommand {
    constructor(cleaner) {
        this.cleaner = cleaner;
    }
    run(input, translationsGlob) {
        return __awaiter(this, void 0, void 0, function* () {
            const keys = keys_1.deserializeKeys(yield stream_1.read(input));
            const translations = yield translations_1.loadTranslations(translationsGlob);
            const cleaned = yield this.cleaner.clean(keys, translations);
            yield Promise.all(cleaned.map(file => translations_1.saveTranslation(file)));
        });
    }
}
exports.CleanCommand = CleanCommand;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cleaner = void 0;
const events_1 = __webpack_require__(2);
const async_1 = __webpack_require__(4);
const translations_1 = __webpack_require__(0);
class Cleaner extends events_1.EventEmitter {
    clean(keys, translations) {
        return __awaiter(this, void 0, void 0, function* () {
            this.emit('cleaning', { keys, translations });
            yield async_1.tick();
            for (const file of translations) {
                for (const key of keys) {
                    if (translations_1.deleteTranslationKey(file.data, key)) {
                        this.emit('removed', { key, file });
                        yield async_1.tick();
                    }
                    else {
                        this.emit('passed', { key, file });
                        yield async_1.tick();
                    }
                }
            }
            this.emit('cleaned', { keys, translations });
            yield async_1.tick();
            return translations;
        });
    }
}
exports.Cleaner = Cleaner;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompareCommand = void 0;
const stream_1 = __webpack_require__(1);
const translations_1 = __webpack_require__(0);
class CompareCommand {
    constructor(comparer) {
        this.comparer = comparer;
    }
    run(output, referencePath, translationsGlob) {
        return __awaiter(this, void 0, void 0, function* () {
            const reference = yield translations_1.loadTranslation(referencePath);
            const translations = yield translations_1.loadTranslations(translationsGlob);
            const compared = yield this.comparer.compare(reference, translations);
            yield stream_1.write(output, translations_1.serializeComparedTranslation(compared));
        });
    }
}
exports.CompareCommand = CompareCommand;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Comparer = void 0;
const events_1 = __webpack_require__(2);
const async_1 = __webpack_require__(4);
const translations_1 = __webpack_require__(0);
class Comparer extends events_1.EventEmitter {
    compare(reference, translations) {
        return __awaiter(this, void 0, void 0, function* () {
            const compared = [];
            this.emit('comparing', { reference, translations });
            yield async_1.tick();
            for (const file of translations) {
                const diffed = translations_1.compareTranslation(reference, file);
                compared.push(diffed);
                this.emit('diff', { file: diffed });
                yield async_1.tick();
            }
            this.emit('compared', { reference, translations: compared });
            yield async_1.tick();
            return compared;
        });
    }
}
exports.Comparer = Comparer;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompleteCommand = void 0;
const stream_1 = __webpack_require__(1);
const translations_1 = __webpack_require__(0);
class CompleteCommand {
    constructor(completer) {
        this.completer = completer;
    }
    run(input, referencePath) {
        return __awaiter(this, void 0, void 0, function* () {
            const diff = yield translations_1.deserializeComparedTranslations(yield stream_1.read(input));
            const reference = yield translations_1.loadTranslation(referencePath);
            const completed = yield this.completer.complete(diff, reference);
            yield Promise.all(completed.map(file => translations_1.saveTranslation(file)));
        });
    }
}
exports.CompleteCommand = CompleteCommand;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Completer = void 0;
const events_1 = __webpack_require__(2);
const async_1 = __webpack_require__(4);
const translations_1 = __webpack_require__(0);
class Completer extends events_1.EventEmitter {
    complete(translations, reference) {
        return __awaiter(this, void 0, void 0, function* () {
            this.emit('completing', { reference, translations });
            yield async_1.tick();
            for (const file of translations) {
                for (const key of file.substractions) {
                    const value = translations_1.getTranslationValue(reference.data, key);
                    if (translations_1.addTranslationKey(file.data, key, value)) {
                        file.keys.push(key);
                        this.emit('added', { file, key, value });
                        yield async_1.tick();
                    }
                    else {
                        this.emit('passed', { file, key, value });
                        yield async_1.tick();
                    }
                }
            }
            this.emit('completed', { reference, translations });
            yield async_1.tick();
            return translations;
        });
    }
}
exports.Completer = Completer;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FormatCommand = void 0;
const translations_1 = __webpack_require__(0);
class FormatCommand {
    run(translationsGlob) {
        return __awaiter(this, void 0, void 0, function* () {
            yield translations_1.saveTranslations(yield translations_1.loadTranslations(translationsGlob));
        });
    }
}
exports.FormatCommand = FormatCommand;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PickCommand = void 0;
const keys_1 = __webpack_require__(3);
const stream_1 = __webpack_require__(1);
const translations_1 = __webpack_require__(0);
const pick_1 = __webpack_require__(20);
class PickCommand {
    run(input, output, translationsGlob) {
        return __awaiter(this, void 0, void 0, function* () {
            const keys = keys_1.deserializeKeys(yield stream_1.read(input));
            const translations = yield translations_1.loadTranslations(translationsGlob);
            const picked = pick_1.pick(keys, translations);
            yield stream_1.write(output, JSON.stringify(picked, null, 2));
        });
    }
}
exports.PickCommand = PickCommand;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.pick = void 0;
const translations_1 = __webpack_require__(0);
function pick(keys, translations) {
    const picked = {};
    keys.forEach(key => {
        picked[key] = {};
        translations.forEach(translation => {
            picked[key][translation.path] = translations_1.getTranslationValue(translation.data, key);
        });
    });
    return picked;
}
exports.pick = pick;


/***/ })
/******/ ]);